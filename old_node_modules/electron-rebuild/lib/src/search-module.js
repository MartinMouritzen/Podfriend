"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
function shouldContinueSearch(traversedPath, rootPath, stopAtPackageJSON) {
    return __awaiter(this, void 0, void 0, function* () {
        if (rootPath) {
            return Promise.resolve(traversedPath !== path.dirname(rootPath));
        }
        else if (stopAtPackageJSON) {
            return fs.pathExists(path.join(traversedPath, 'package.json'));
        }
        else {
            return true;
        }
    });
}
function traverseAncestorDirectories(cwd, pathGenerator, rootPath, maxItems, stopAtPackageJSON) {
    return __awaiter(this, void 0, void 0, function* () {
        const paths = [];
        let traversedPath = path.resolve(cwd);
        while (yield shouldContinueSearch(traversedPath, rootPath, stopAtPackageJSON)) {
            const generatedPath = pathGenerator(traversedPath);
            if (yield fs.pathExists(generatedPath)) {
                paths.push(generatedPath);
            }
            const parentPath = path.dirname(traversedPath);
            if (parentPath === traversedPath || (maxItems && paths.length >= maxItems)) {
                break;
            }
            traversedPath = parentPath;
        }
        return paths;
    });
}
/**
 * Find all instances of a given module in node_modules subdirectories while traversing up
 * ancestor directories.
 *
 * @param cwd the initial directory to traverse
 * @param moduleName the Node module name (should work for scoped modules as well)
 * @param rootPath the project's root path. If provided, the traversal will stop at this path.
 */
function searchForModule(cwd, moduleName, rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const pathGenerator = (traversedPath) => path.join(traversedPath, 'node_modules', moduleName);
        return traverseAncestorDirectories(cwd, pathGenerator, rootPath, undefined, true);
    });
}
exports.searchForModule = searchForModule;
/**
 * Find all instances of node_modules subdirectories while traversing up ancestor directories.
 *
 * @param cwd the initial directory to traverse
 * @param rootPath the project's root path. If provided, the traversal will stop at this path.
 */
function searchForNodeModules(cwd, rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const pathGenerator = (traversedPath) => path.join(traversedPath, 'node_modules');
        return traverseAncestorDirectories(cwd, pathGenerator, rootPath, undefined, true);
    });
}
exports.searchForNodeModules = searchForNodeModules;
/**
 * Determine the root directory of a given project, by looking for a directory with an
 * NPM or yarn lockfile.
 *
 * @param cwd the initial directory to traverse
 */
function getProjectRootPath(cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        for (const lockFilename of ['yarn.lock', 'package-lock.json']) {
            const pathGenerator = (traversedPath) => path.join(traversedPath, lockFilename);
            const lockPaths = yield traverseAncestorDirectories(cwd, pathGenerator, undefined, 1);
            if (lockPaths.length > 0) {
                return path.dirname(lockPaths[0]);
            }
        }
        return cwd;
    });
}
exports.getProjectRootPath = getProjectRootPath;
//# sourceMappingURL=search-module.js.map