import { ok, throws } from 'assert';

import t from './globalContext';

var no = function no(input) {
  return ok(!input);
};

describe('Typed API', function () {
  it('should check a string', function () {
    var type = t.string();
    ok(type.accepts('helo world'));
    no(type.accepts(false));
  });

  it('should check a simple object', function () {
    var type = t.object(t.property('foo', t.boolean()), t.property('bar', t.string('hello')));

    ok(type.accepts({
      foo: true,
      bar: 'hello'
    }));
  });

  it('should check nullable types', function () {
    var type = t.nullable(t.string());

    ok(type.accepts());
    ok(type.accepts(null));
    ok(type.accepts(undefined));
    ok(type.accepts(''));
    ok(type.accepts('foo'));
    no(type.accepts(2));
    no(type.accepts(true));
  });

  it('should assert nullable types', function () {
    var type = t.nullable(t.string());

    type.assert();
    type.assert(null);
    type.assert(undefined);
    type.assert('');
    type.assert('foo');
  });

  it('should check a simple object with shortcut syntax', function () {
    var type = t.exactObject({
      foo: t.boolean(),
      bar: t.string()
    });

    ok(type.accepts({
      foo: true,
      bar: 'hello'
    }));

    no(type.accepts({
      foo: true,
      bar: 'hello',
      baz: 44
    }));

    no(type.accepts({
      foo: 123
    }));
  });

  it('should check an exact object', function () {
    var type = t.object({
      foo: t.boolean(),
      bar: t.string()
    });

    ok(type.accepts({
      foo: true,
      bar: 'hello'
    }));

    no(type.accepts({
      foo: 123
    }));
  });

  it('should make a tuple type', function () {
    var type = t.tuple(t.string(), t.number(), t.boolean());

    ok(type.accepts(['hello', 213, true]));
    ok(type.accepts(['hello', 213, true, 'still ok']));
    no(type.accepts(['hello', 213, 'nah']));
  });

  it('should declare a named type', function () {
    var User = t.declare('User', t.object(t.property('id', t.number()), t.property('name', t.string())));

    User.addConstraint(function (input) {
      if (input.name.length <= 2) {
        return "Name is too short!";
      } else if (input.name.length >= 45) {
        return "Name is too long!";
      }
    });

    no(User.accepts({
      id: 123,
      name: false
    }));

    no(User.accepts({
      id: 123,
      name: ''
    }));
    ok(User.accepts({
      id: 123,
      name: 'this is valid'
    }));
    ok(User.accepts({
      id: 123,
      name: 'this is valid',
      extra: 'okay'
    }));
  });

  it('should use a Map<string, number>', function () {
    var type = t.ref(Map, t.string(), t.number());
    ok(type.accepts(new Map()));
    ok(type.accepts(new Map([['valid', 123]])));
    no(type.accepts(new Map([['valid', 123], ['notvalid', false]])));
  });

  it('should make a simple function type', function () {
    var type = t.fn(t.param('input', t.boolean()), t.param('etc', t.boolean(), true), t.return(t.string()));

    var good = function good(input) {
      return input ? 'yes' : 'no';
    };
    var better = function better(input, etc) {
      return input && etc ? 'yes' : 'no';
    };
    var bad = function bad() {
      return undefined;
    };
    ok(type.accepts(good));
    ok(type.accepts(better));
    ok(type.accepts(bad)); // not enough type information to reject.
  });

  it('should make a parameterized function type', function () {
    var type = t.fn(function (fn) {
      var T = fn.typeParameter('T', t.union(t.string(), t.number()));
      return [t.param('input', T), t.param('etc', t.boolean(), true), t.return(t.nullable(T))];
    });

    function good(input) {
      return input;
    }
    function better(input, etc) {
      return etc ? input : null;
    }
    function bad() {
      return;
    }
    ok(type.accepts(good));
    ok(type.accepts(better));
    ok(type.accepts(bad)); // not enough type information to reject.
  });

  it('should build a tree-like object', function () {
    var Tree = t.type('Tree', function (Tree) {
      var T = Tree.typeParameter('T');
      return t.object(t.property('value', T), t.property('left', t.nullable(t.ref(Tree, T))), t.property('right', t.nullable(t.ref(Tree, T))));
    });
    var candidate = {
      value: 'hello world',
      left: null,
      right: {
        value: 'foo',
        left: null,
        right: null
      }
    };
    ok(Tree.assert(candidate));
  });

  it('should apply type parameters', function () {
    var A = t.type("A", function (A) {
      var T = A.typeParameter("T");
      return T;
    });
    var B = t.type("B", t.ref(A, t.string()));

    ok(B.assert("abc"));
    ok(A.assert(123));
    throws(function () {
      return B.assert(123);
    });
  });

  it('should handle named types', function () {
    var UserEmailAddress = t.type('UserEmailAddress', t.string());
    UserEmailAddress.addConstraint(function (input) {
      if (!/@/.test(input)) {
        return "must be a valid email address";
      }
    });

    var User = t.type('User', t.object(t.property('id', t.number()), t.property('name', t.string()), t.property('email', UserEmailAddress)));

    var sally = {
      id: 123,
      name: 'Sally',
      email: 'invalid'
    };

    throws(function () {
      return User.assert(sally);
    });
    sally.email = 'sally@example.com';
    User.assert(sally);
  });

  it('should handle Class<User>', function () {
    var _dec, _class, _dec2, _class2;

    var User = (_dec = t.decorate(t.object(t.property('id', t.number()), t.property('name', t.string()), t.property('email', t.string()))), _dec(_class = function User() {
      babelHelpers.classCallCheck(this, User);
    }) || _class);

    var AdminUser = function (_User) {
      babelHelpers.inherits(AdminUser, _User);

      function AdminUser() {
        babelHelpers.classCallCheck(this, AdminUser);
        return babelHelpers.possibleConstructorReturn(this, (AdminUser.__proto__ || Object.getPrototypeOf(AdminUser)).apply(this, arguments));
      }

      return AdminUser;
    }(User);

    var Role = (_dec2 = t.decorate(t.object(t.property('name', t.string()))), _dec2(_class2 = function Role() {
      babelHelpers.classCallCheck(this, Role);
    }) || _class2);


    var INameable = t.type('Nameable', t.object(t.property('name', t.string())));
    var INomable = t.type('Nameable', t.object(t.property('nom', t.string())));
    var INameableClass = t.ref('Class', INameable);
    var INomableClass = t.ref('Class', INomable);

    var IUserClass = t.ref('Class', t.ref(User));
    var IAdminUserClass = t.ref('Class', t.ref(AdminUser));
    no(IUserClass.accepts(Role));
    ok(IUserClass.accepts(User));
    ok(IUserClass.accepts(AdminUser));

    no(IAdminUserClass.accepts(Role));
    no(IAdminUserClass.accepts(User));
    ok(IAdminUserClass.accepts(AdminUser));

    ok(INameableClass.accepts(User));
    ok(INameableClass.accepts(Role));
    ok(INameableClass.accepts(AdminUser));
    no(INomableClass.accepts(User));

    //t.ref(Map, t.string(), t.number()).assert(new Map([['hello', false]]));
  });

  it('should $Diff<A, B>', function () {
    var A = t.object(t.property('name', t.string()), t.property('email', t.string()));
    var B = t.object(t.property('email', t.string('example@example.com')));

    var C = t.ref('$Diff', A, B);

    no(C.accepts({}));
    ok(C.accepts({ name: 'Alice' }));
    ok(C.accepts({ name: 'Alice', email: 'alice@example.com' }));
    no(C.accepts({ email: 'alice@example.com' }));
    no(C.accepts({ name: false, email: 'alice@example.com' }));
  });

  it('should $Shape<A>', function () {
    var A = t.object(t.property('name', t.string()), t.property('email', t.string()));
    var B = t.ref('$Shape', A);

    ok(B.accepts({}));
    ok(B.accepts({ name: 'Alice' }));
    ok(B.accepts({ name: 'Alice', email: 'alice@example.com' }));
    no(B.accepts({ nope: false }));
    no(B.accepts({ name: false, email: 'alice@example.com' }));
    no(B.accepts({ name: 'Alice', email: 'alice@example.com', extra: true }));
  });

  it('should $Keys<A>', function () {
    var A = t.object(t.property('name', t.string()), t.property('email', t.string()));
    var B = t.ref('$Keys', A);

    ok(B.accepts('name'));
    ok(B.accepts('email'));
    no(B.accepts('nope'));
    no(B.accepts(false));
    no(B.accepts({}));
  });

  it('should $Keys<typeOf A>', function () {
    var A = t.typeOf({
      name: 'Alice',
      email: 'example@example.com'
    });
    var B = t.ref('$Keys', A);

    ok(B.accepts('name'));
    ok(B.accepts('email'));
    no(B.accepts('nope'));
    no(B.accepts(false));
    no(B.accepts({}));
  });

  it.skip('should $ObjMap<K, V>', function () {
    var K = t.object(t.property('name', t.string()), t.property('email', t.string()));
    var V = t.fn(function (fn) {
      var K = fn.typeParameter('K');
      var V = fn.typeParameter('V');
      return [t.param('key', K), t.param('value', V), t.return(t.tuple(K, V))];
    });
    var B = t.ref('$ObjMap', K, V);

    B.assert({
      name: ['name', 'Hello'],
      email: ['email', 'World']
    });
    ok(B.accepts({}));
    ok(B.accepts({ name: 'Alice' }));
    ok(B.accepts({ name: 'Alice', email: 'alice@example.com' }));
    no(B.accepts({ nope: false }));
    no(B.accepts({ name: false, email: 'alice@example.com' }));
    no(B.accepts({ name: 'Alice', email: 'alice@example.com', extra: true }));
  });

  it('should build an object', function () {
    t.object(t.property('foo', t.string('bar')), t.property('qux', t.union(t.string(), t.number(), t.boolean())), t.property('nested', t.object(t.property('again', t.object(t.indexer('nom', t.string(), t.any()), t.property('hello', t.string('world')), t.property('bar', t.string()), t.property('meth', t.fn(t.param('a', t.boolean(false)), t.return(t.string()))), t.method('m', function (fn) {
      var T = fn.typeParameter('T');
      return [t.param('a', T), t.return(T)];
    }), t.property('typed', t.fn(function (fn) {
      var T = fn.typeParameter('T', t.string());
      return [t.param('input', T), t.return(t.object(t.property('nn', T)))];
    })))))));
  });
});