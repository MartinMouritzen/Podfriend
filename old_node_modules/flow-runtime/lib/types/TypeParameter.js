import Type from './Type';


import FlowIntoType from './FlowIntoType';

var FlowIntoSymbol = Symbol('FlowInto');

/**
 * # TypeParameter
 *
 * Type parameters allow polymorphic type safety.
 * The first time a type parameter is checked, it records the shape of its input,
 * this recorded shape is used to check all future inputs for this particular instance.
 */

var TypeParameter = function (_Type) {
  babelHelpers.inherits(TypeParameter, _Type);

  function TypeParameter() {
    var _ref;

    var _temp, _this, _ret;

    babelHelpers.classCallCheck(this, TypeParameter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TypeParameter.__proto__ || Object.getPrototypeOf(TypeParameter)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'TypeParameter', _this[FlowIntoSymbol] = null, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
  }

  // Issue 252


  babelHelpers.createClass(TypeParameter, [{
    key: 'collectErrors',
    value: function collectErrors(validation, path, input) {
      var recorded = this.recorded,
          bound = this.bound,
          context = this.context;

      if (bound instanceof FlowIntoType) {
        // We defer to the other type parameter so that values from this
        // one can flow "upwards".
        return bound.accepts(input);
      } else if (recorded) {
        // we've already recorded a value for this type parameter
        return recorded.collectErrors(validation, path, input);
      } else if (bound) {
        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {
          return false;
        } else if (bound.collectErrors(validation, path, input)) {
          return true;
        }
      }

      this.recorded = context.typeOf(input);
      return false;
    }
  }, {
    key: 'accepts',
    value: function accepts(input) {
      var recorded = this.recorded,
          bound = this.bound,
          context = this.context;

      if (bound instanceof FlowIntoType) {
        // We defer to the other type parameter so that values from this
        // one can flow "upwards".
        return bound.accepts(input);
      } else if (recorded) {
        return recorded.accepts(input);
      } else if (bound) {
        if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {
          return true;
        } else if (!bound.accepts(input)) {
          return false;
        }
      }

      this.recorded = context.typeOf(input);
      return true;
    }
  }, {
    key: 'acceptsType',
    value: function acceptsType(input) {
      var recorded = this.recorded,
          bound = this.bound;

      if (input instanceof TypeParameter) {
        // We don't need to check for `recorded` or `bound` fields
        // because the input has already been unwrapped.
        return true;
      } else if (recorded) {
        return recorded.acceptsType(input);
      } else if (bound) {
        return bound.acceptsType(input);
      } else {
        // A generic type parameter accepts any input.
        return true;
      }
    }

    /**
     * Get the inner type or value.
     */

  }, {
    key: 'unwrap',
    value: function unwrap() {
      var recorded = this.recorded,
          bound = this.bound;

      if (recorded) {
        return recorded.unwrap();
      } else if (bound) {
        return bound.unwrap();
      } else {
        return this;
      }
    }
  }, {
    key: 'toString',
    value: function toString(withBinding) {
      var id = this.id,
          bound = this.bound;

      if (withBinding && bound) {
        return `${ id }: ${ bound.toString() }`;
      }
      return id;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        typeName: this.typeName,
        id: this.id,
        bound: this.bound,
        recorded: this.recorded
      };
    }
  }]);
  return TypeParameter;
}(Type);

export { TypeParameter as default };


export function flowIntoTypeParameter(typeParameter) {
  var existing = typeParameter[FlowIntoSymbol];
  if (existing) {
    return existing;
  }

  var target = new FlowIntoType(typeParameter.context);
  target.typeParameter = typeParameter;
  typeParameter[FlowIntoSymbol] = target;
  return target;
}