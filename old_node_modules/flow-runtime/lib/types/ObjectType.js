import Type from './Type';

import ObjectTypeProperty from './ObjectTypeProperty';
import ObjectTypeIndexer from './ObjectTypeIndexer';
import ObjectTypeCallProperty from './ObjectTypeCallProperty';

import getErrorMessage from "../getErrorMessage";


import { inValidationCycle, startValidationCycle, endValidationCycle, inToStringCycle, startToStringCycle, endToStringCycle } from '../cyclic';

var ObjectType = function (_Type) {
  babelHelpers.inherits(ObjectType, _Type);

  function ObjectType() {
    var _ref;

    var _temp, _this, _ret;

    babelHelpers.classCallCheck(this, ObjectType);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
  }

  babelHelpers.createClass(ObjectType, [{
    key: 'getProperty',


    /**
     * Get a property with the given name, or undefined if it does not exist.
     */
    value: function getProperty(key) {
      var properties = this.properties;
      var length = properties.length;

      for (var i = 0; i < length; i++) {
        var property = properties[i];
        if (property.key === key) {
          return property;
        }
      }
      return this.getIndexer(key);
    }

    /**
     * Determine whether a property with the given name exists.
     */

  }, {
    key: 'hasProperty',
    value: function hasProperty(key) {
      var properties = this.properties;
      var length = properties.length;

      for (var i = 0; i < length; i++) {
        var property = properties[i];
        if (property.key === key) {
          return true;
        }
      }
      return this.hasIndexer(key);
    }

    /**
     * Get an indexer with which matches the given key type.
     */

  }, {
    key: 'getIndexer',
    value: function getIndexer(key) {
      var indexers = this.indexers;
      var length = indexers.length;

      for (var i = 0; i < length; i++) {
        var indexer = indexers[i];
        if (indexer.acceptsKey(key)) {
          return indexer;
        }
      }
    }

    /**
     * Determine whether an indexer exists which matches the given key type.
     */

  }, {
    key: 'hasIndexer',
    value: function hasIndexer(key) {
      var indexers = this.indexers;
      var length = indexers.length;

      for (var i = 0; i < length; i++) {
        var indexer = indexers[i];
        if (indexer.acceptsKey(key)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'collectErrors',
    value: function collectErrors(validation, path, input) {
      if (input === null) {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));
        return true;
      }

      var hasCallProperties = this.callProperties.length > 0;

      if (hasCallProperties) {
        if (!acceptsCallProperties(this, input)) {
          validation.addError(path, this, getErrorMessage('ERR_EXPECT_CALLABLE'));
        }
      } else if (typeof input !== 'object') {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));
        return true;
      }
      if (inValidationCycle(this, input)) {
        return false;
      }
      startValidationCycle(this, input);

      var result = void 0;

      if (this.indexers.length > 0) {
        result = collectErrorsWithIndexers(this, validation, path, input);
      } else if (this.exact) {
        result = collectErrorsExact(this, validation, path, input);
      } else {
        result = collectErrorsWithoutIndexers(this, validation, path, input);
      }
      endValidationCycle(this, input);
      return result;
    }
  }, {
    key: 'accepts',
    value: function accepts(input) {
      if (input === null) {
        return false;
      }
      var hasCallProperties = this.callProperties.length > 0;

      if (hasCallProperties) {
        if (!acceptsCallProperties(this, input)) {
          return false;
        }
      } else if (typeof input !== 'object') {
        return false;
      }
      if (inValidationCycle(this, input)) {
        return true;
      }
      startValidationCycle(this, input);

      var result = void 0;
      if (this.indexers.length > 0) {
        result = acceptsWithIndexers(this, input);
      } else if (this.exact) {
        result = acceptsExact(this, input);
      } else {
        result = acceptsWithoutIndexers(this, input);
      }
      endValidationCycle(this, input);
      return result;
    }
  }, {
    key: 'acceptsType',
    value: function acceptsType(input) {
      if (!(input instanceof ObjectType)) {
        return false;
      }
      var hasCallProperties = this.callProperties.length > 0;

      if (hasCallProperties && !acceptsTypeCallProperties(this, input)) {
        return false;
      }

      if (this.indexers.length > 0) {
        return acceptsTypeWithIndexers(this, input);
      } else {
        return acceptsTypeWithoutIndexers(this, input);
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      var callProperties = this.callProperties,
          properties = this.properties,
          indexers = this.indexers;

      if (inToStringCycle(this)) {
        return '$Cycle<Object>';
      }
      startToStringCycle(this);
      var body = [];
      for (var i = 0; i < callProperties.length; i++) {
        body.push(callProperties[i].toString());
      }
      for (var _i = 0; _i < properties.length; _i++) {
        body.push(properties[_i].toString());
      }
      for (var _i2 = 0; _i2 < indexers.length; _i2++) {
        body.push(indexers[_i2].toString());
      }
      endToStringCycle(this);
      if (this.exact) {
        return `{|\n${ indent(body.join('\n')) }\n|}`;
      } else {
        return `{\n${ indent(body.join('\n')) }\n}`;
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        typeName: this.typeName,
        callProperties: this.callProperties,
        properties: this.properties,
        indexers: this.indexers,
        exact: this.exact
      };
    }
  }]);
  return ObjectType;
}(Type);

export { ObjectType as default };


function acceptsCallProperties(type, input) {
  if (typeof input !== 'function') {
    return false;
  }
  var callProperties = type.callProperties;

  for (var i = 0; i < callProperties.length; i++) {
    var callProperty = callProperties[i];
    if (callProperty.accepts(input)) {
      return true;
    }
  }
  return false;
}

function acceptsTypeCallProperties(type, input) {
  var callProperties = type.callProperties;

  var inputCallProperties = input.callProperties;
  loop: for (var i = 0; i < callProperties.length; i++) {
    var callProperty = callProperties[i];

    for (var j = 0; j < inputCallProperties.length; j++) {
      var inputCallProperty = inputCallProperties[j];
      if (callProperty.acceptsType(inputCallProperty)) {
        continue loop;
      }
    }
    // If we got this far, nothing accepted.
    return false;
  }
  return true;
}

function acceptsWithIndexers(type, input) {
  var properties = type.properties,
      indexers = type.indexers;

  var seen = [];
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (!property.accepts(input)) {
      return false;
    }
    seen.push(property.key);
  }
  loop: for (var key in input) {
    if (seen.indexOf(key) !== -1) {
      continue;
    }
    var value = input[key];
    for (var _i3 = 0; _i3 < indexers.length; _i3++) {
      var indexer = indexers[_i3];
      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {
        continue loop;
      }
    }

    // if we got this far the key / value did not accepts any indexers.
    return false;
  }
  return true;
}

function acceptsTypeWithIndexers(type, input) {
  var indexers = type.indexers,
      properties = type.properties;

  var inputIndexers = input.indexers;
  var inputProperties = input.properties;
  loop: for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    for (var j = 0; j < inputProperties.length; j++) {
      var inputProperty = inputProperties[j];
      if (inputProperty.key === property.key) {
        if (property.acceptsType(inputProperty)) {
          continue loop;
        } else {
          return false;
        }
      }
    }
  }
  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {
    var indexer = indexers[_i4];
    for (var _j = 0; _j < inputIndexers.length; _j++) {
      var inputIndexer = inputIndexers[_j];
      if (indexer.acceptsType(inputIndexer)) {
        continue loop;
      }
    }
    // if we got this far, nothing accepted
    return false;
  }
  return true;
}

function acceptsWithoutIndexers(type, input) {
  var properties = type.properties;

  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (!property.accepts(input)) {
      return false;
    }
  }
  return true;
}

function acceptsExact(type, input) {
  var properties = type.properties;
  var length = properties.length;

  loop: for (var key in input) {
    // eslint-disable-line guard-for-in
    for (var i = 0; i < length; i++) {
      var property = properties[i];
      if (property.key === key) {
        if (!property.accepts(input)) {
          return false;
        }
        continue loop;
      }
    }
    // if we got this far the property does not exist in the object.
    return false;
  }
  return true;
}

function acceptsTypeWithoutIndexers(type, input) {
  var properties = type.properties;

  var inputProperties = input.properties;
  loop: for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    for (var j = 0; j < inputProperties.length; j++) {
      var inputProperty = inputProperties[j];
      if (inputProperty.key === property.key) {
        if (property.acceptsType(inputProperty)) {
          continue loop;
        } else {
          return false;
        }
      }
    }
    return false;
  }
  return true;
}

function collectErrorsWithIndexers(type, validation, path, input) {
  var properties = type.properties,
      indexers = type.indexers;

  var seen = [];
  var hasErrors = false;
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (property.collectErrors(validation, path, input)) {
      hasErrors = true;
    }
    seen.push(property.key);
  }
  loop: for (var key in input) {
    if (seen.indexOf(key) !== -1) {
      continue;
    }
    var value = input[key];
    for (var _i5 = 0; _i5 < indexers.length; _i5++) {
      var indexer = indexers[_i5];
      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {
        continue loop;
      }
    }

    // if we got this far the key / value was not accepted by any indexers.
    validation.addError(path.concat(key), type, getErrorMessage('ERR_NO_INDEXER'));
    hasErrors = true;
  }
  return hasErrors;
}

function collectErrorsWithoutIndexers(type, validation, path, input) {
  var properties = type.properties;

  var hasErrors = false;
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (property.collectErrors(validation, path, input)) {
      hasErrors = true;
    }
  }
  return hasErrors;
}

function collectErrorsExact(type, validation, path, input) {
  var properties = type.properties;
  var length = properties.length;

  var hasErrors = false;
  loop: for (var key in input) {
    // eslint-disable-line guard-for-in
    for (var i = 0; i < length; i++) {
      var property = properties[i];
      if (property.key === key) {
        if (property.collectErrors(validation, path, input)) {
          hasErrors = true;
        }
        continue loop;
      }
    }
    // if we got this far the property does not exist in the object.
    validation.addError(path, type, getErrorMessage('ERR_UNKNOWN_KEY', key));
    hasErrors = true;
  }
  return hasErrors;
}

function indent(input) {
  var lines = input.split('\n');
  var length = lines.length;

  for (var i = 0; i < length; i++) {
    lines[i] = `  ${ lines[i] }`;
  }
  return lines.join('\n');
}