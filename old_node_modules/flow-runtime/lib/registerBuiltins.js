import getErrorMessage from "./getErrorMessage";

import invariant from './invariant';

import { Type, TypeParameterApplication, GenericType, ObjectType } from './types';


export default function registerBuiltinTypeConstructors(t) {

  // Notes from: http://sitr.us/2015/05/31/advanced-features-in-flow.html
  // and the flow source code.

  // Type of the class whose instances are of type T.
  // This lets you pass around classes as first-class values.
  t.declareTypeConstructor({
    name: 'Class',
    typeName: 'ClassType',
    collectErrors(validation, path, input, instanceType) {
      if (typeof input !== 'function') {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()));
        return true;
      }
      var expectedType = instanceType.unwrap();
      if (expectedType instanceof GenericType && typeof expectedType.impl === 'function') {
        if (input === expectedType.impl) {
          return false;
        } else if (expectedType.impl.prototype.isPrototypeOf(input.prototype)) {
          return false;
        } else {
          validation.addError(path, this, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()));
          return true;
        }
      }
      var annotation = t.getAnnotation(input);
      if (annotation) {
        return expectedType.acceptsType(annotation);
      }
      var matches = void 0;
      // we're dealing with a type
      switch (input.typeName) {
        case 'NumberType':
        case 'NumericLiteralType':
          matches = input === Number;
          break;
        case 'BooleanType':
        case 'BooleanLiteralType':
          matches = input === Boolean;
          break;
        case 'StringType':
        case 'StringLiteralType':
          matches = input === String;
          break;
        case 'ArrayType':
        case 'TupleType':
          matches = input === Array;
          break;
        default:
          return false;
      }
      if (matches) {
        return false;
      } else {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()));
        return true;
      }
    },
    accepts(input, instanceType) {
      if (typeof input !== 'function') {
        return false;
      }
      var expectedType = instanceType.unwrap();
      if (expectedType instanceof GenericType && typeof expectedType.impl === 'function') {
        if (input === expectedType.impl) {
          return true;
        } else if (typeof expectedType.impl === 'function') {
          if (expectedType.impl.prototype.isPrototypeOf(input.prototype)) {
            return true;
          } else {
            return false;
          }
        }
      }

      var annotation = t.getAnnotation(input);

      if (annotation) {
        return expectedType.acceptsType(annotation);
      } else if (expectedType instanceof TypeParameterApplication) {
        expectedType = expectedType.parent;
      }

      if (expectedType instanceof GenericType && typeof expectedType.impl === 'function') {
        if (expectedType.impl.prototype.isPrototypeOf(input.prototype)) {
          return true;
        } else {
          return false;
        }
      }

      // we're dealing with a type
      switch (input.typeName) {
        case 'NumberType':
        case 'NumericLiteralType':
          return input === Number;
        case 'BooleanType':
        case 'BooleanLiteralType':
          return input === Boolean;
        case 'StringType':
        case 'StringLiteralType':
          return input === String;
        case 'ArrayType':
        case 'TupleType':
          return input === Array;
        default:
          return false;
      }
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // If A and B are object types, $Diff<A,B> is the type of objects that have
  // properties defined in A, but not in B.
  // Properties that are defined in both A and B are allowed too.
  t.declareTypeConstructor({
    name: '$Diff',
    typeName: '$DiffType',
    collectErrors(validation, path, input, aType, bType) {
      if (input === null || typeof input !== "object" && typeof input !== "function") {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));
        return true;
      }
      aType = aType.unwrap();
      invariant(bType, "Must specify two type parameters.");
      bType = bType.unwrap();
      invariant(aType instanceof ObjectType && bType instanceof ObjectType, "Can only $Diff object types.");
      var hasErrors = false;
      var properties = aType.properties;
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (bType.hasProperty(property.key)) {
          continue;
        }
        if (property.collectErrors(validation, path.concat(property.key), input)) {
          hasErrors = true;
        }
      }
      return hasErrors;
    },
    accepts(input, aType, bType) {
      if (input === null || typeof input !== "object" && typeof input !== "function") {
        return false;
      }
      aType = aType.unwrap();
      bType = bType.unwrap();
      invariant(aType instanceof ObjectType && bType instanceof ObjectType, "Can only $Diff object types.");
      var properties = aType.properties;
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (bType.hasProperty(property.key)) {
          continue;
        }
        if (!property.accepts(input)) {
          return false;
        }
      }
      return true;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // An object of type $Shape<T> does not have to have all of the properties
  // that type T defines. But the types of the properties that it does have
  // must accepts the types of the same properties in T.
  t.declareTypeConstructor({
    name: '$Shape',
    typeName: '$ShapeType',
    collectErrors(validation, path, input, shapeType) {
      if (input === null || typeof input !== "object" && typeof input !== "function") {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));
        return true;
      }
      shapeType = shapeType.unwrap();
      invariant(typeof shapeType.getProperty === 'function', "Can only $Shape<T> object types.");

      var hasErrors = false;
      for (var key in input) {
        // eslint-disable-line guard-for-in
        var property = shapeType.getProperty(key);
        if (!property) {
          continue;
        }
        if (property.collectErrors(validation, path, input)) {
          hasErrors = true;
        }
      }

      return hasErrors;
    },
    accepts(input, shapeType) {
      if (input === null || typeof input !== "object" && typeof input !== "function") {
        return false;
      }
      shapeType = shapeType.unwrap();
      invariant(typeof shapeType.getProperty === 'function', "Can only $Shape<T> object types.");
      for (var key in input) {
        // eslint-disable-line guard-for-in
        var property = shapeType.getProperty(key);
        if (!property || !property.accepts(input)) {
          return false;
        }
      }
      return true;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // Any, but at least T.
  t.declareTypeConstructor({
    name: '$SuperType',
    typeName: '$SuperType',
    collectErrors(validation, path, input, superType) {
      return superType.collectErrors(validation, path, input);
    },
    accepts(input, superType) {
      return superType.accepts(input);
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // object with larger key set than X's
  t.declareTypeConstructor({
    name: '$SubType',
    typeName: '$SubType',
    collectErrors(validation, path, input, subType) {
      return subType.collectErrors(validation, path, input);
    },
    accepts(input, subType) {
      return subType.accepts(input);
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // map over the key in an object.
  t.declareTypeConstructor({
    name: '$ObjMap',
    typeName: '$ObjMap',
    collectErrors(validation, path, input, object, mapper) {
      var target = object.unwrap();
      invariant(mapper, 'Must specify at least two type parameters.');
      invariant(Array.isArray(target.properties), 'Target must be an object type.');

      var hasErrors = false;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = target.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var prop = _step.value;

          prop;
          var applied = mapper.unwrap(prop.value.unwrap());
          applied;

          var returnType = applied.returnType.unwrap();
          var value = input[prop.key];
          if (returnType.collectErrors(validation, path.concat(prop.key), value)) {
            hasErrors = true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return hasErrors;
    },
    accepts(input, object, mapper) {
      var target = object.unwrap();
      invariant(Array.isArray(target.properties), 'Target must be an object type.');

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = target.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var prop = _step2.value;

          prop;
          var applied = mapper.unwrap(prop.value.unwrap());
          applied;

          var returnType = applied.returnType.unwrap();
          if (!returnType.accepts(input[prop.key])) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return true;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // map over the key in an object.
  t.declareTypeConstructor({
    name: '$ObjMapi',
    typeName: '$ObjMapi',
    collectErrors(validation, path, input, object, mapper) {
      var target = object.unwrap();
      invariant(mapper, 'Must specify at least two type parameters.');
      invariant(Array.isArray(target.properties), 'Target must be an object type.');

      var hasErrors = false;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = target.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var prop = _step3.value;

          prop;
          var applied = mapper.unwrap(this.context.string(prop.key), prop.value.unwrap());
          applied;

          var value = input[prop.key];
          var returnType = applied.returnType.unwrap();
          if (returnType.collectErrors(validation, path.concat(prop.key), value)) {
            hasErrors = true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return hasErrors;
    },
    accepts(input, object, mapper) {
      var target = object.unwrap();
      invariant(Array.isArray(target.properties), 'Target must be an object type.');

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = target.properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var prop = _step4.value;

          prop;
          var applied = mapper.unwrap(this.context.string(prop.key), prop.value.unwrap());
          applied;

          var value = input[prop.key];
          var returnType = applied.returnType.unwrap();
          if (!returnType.accepts(value)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return true;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  // The set of keys of T.
  t.declareTypeConstructor({
    name: '$Keys',
    typeName: '$KeysType',
    collectErrors(validation, path, input, subject) {
      subject = subject.unwrap();
      invariant(subject instanceof ObjectType, '$Keys<T> - T must be an ObjectType.');
      var properties = subject.properties;
      var length = properties.length;
      for (var i = 0; i < length; i++) {
        var property = properties[i];
        if (input === property.key) {
          return false;
        }
      }
      var keys = new Array(length);
      for (var _i = 0; _i < length; _i++) {
        keys[_i] = properties[_i].key;
      }
      validation.addError(path, this, getErrorMessage('ERR_NO_UNION', keys.join(' | ')));
      return true;
    },
    accepts(input, subject) {
      subject = subject.unwrap();
      invariant(subject instanceof ObjectType, '$Keys<T> - T must be an ObjectType.');
      var properties = subject.properties;
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (input === property.key) {
          return true;
        }
      }
      return false;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  t.declareTypeConstructor({
    name: 'Date',
    impl: Date,
    typeName: 'DateType',
    collectErrors(validation, path, input) {
      if (!(input instanceof Date)) {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', Date));
        return true;
      } else if (isNaN(input.getTime())) {
        validation.addError(path, this, getErrorMessage('ERR_INVALID_DATE'));
        return true;
      } else {
        return false;
      }
    },
    accepts(input) {
      return input instanceof Date && !isNaN(input.getTime());
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  t.declareTypeConstructor({
    name: 'Iterable',
    typeName: 'IterableType',
    collectErrors(validation, path, input, keyType) {
      if (!input) {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));
        return true;
      } else if (typeof input[Symbol.iterator] !== 'function') {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_ITERABLE'));
        return true;
      }
      return false;
    },
    accepts(input, keyType) {
      if (!input || typeof input[Symbol.iterator] !== 'function') {
        return false;
      }
      return true;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  t.declareTypeConstructor({
    name: 'Promise',
    impl: Promise,
    typeName: 'PromiseType',
    collectErrors(validation, path, input, futureType) {
      var context = this.context;

      if (!context.checkPredicate('Promise', input)) {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_PROMISE', futureType));
        return true;
      }
      return false;
    },
    accepts(input) {
      var context = this.context;

      return context.checkPredicate('Promise', input);
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  t.declareTypeConstructor({
    name: 'Map',
    impl: Map,
    typeName: 'MapType',
    collectErrors(validation, path, input, keyType, valueType) {
      invariant(valueType, "Must specify two type parameters.");
      var context = this.context;

      if (!context.checkPredicate('Map', input)) {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'));
        return true;
      }
      var hasErrors = false;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = input[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _ref = _step5.value;

          var _ref2 = babelHelpers.slicedToArray(_ref, 2);

          var key = _ref2[0];
          var value = _ref2[1];

          if (!keyType.accepts(key)) {
            validation.addError(path, this, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType));
            hasErrors = true;
          }
          if (valueType.collectErrors(validation, path.concat(key), value)) {
            hasErrors = true;
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return hasErrors;
    },
    accepts(input, keyType, valueType) {
      var context = this.context;

      if (!context.checkPredicate('Map', input)) {
        return false;
      }
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = input[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _ref3 = _step6.value;

          var _ref4 = babelHelpers.slicedToArray(_ref3, 2);

          var key = _ref4[0];
          var value = _ref4[1];

          if (!keyType.accepts(key) || !valueType.accepts(value)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return true;
    },
    inferTypeParameters(input) {
      var keyTypes = [];
      var valueTypes = [];
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        loop: for (var _iterator7 = input[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _ref5 = _step7.value;

          var _ref6 = babelHelpers.slicedToArray(_ref5, 2);

          var key = _ref6[0];
          var value = _ref6[1];

          findKey: {
            for (var i = 0; i < keyTypes.length; i++) {
              var type = keyTypes[i];
              if (type.accepts(key)) {
                break findKey;
              }
            }
            keyTypes.push(t.typeOf(key));
          }

          for (var _i2 = 0; _i2 < valueTypes.length; _i2++) {
            var _type = valueTypes[_i2];
            if (_type.accepts(value)) {
              continue loop;
            }
          }
          valueTypes.push(t.typeOf(value));
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      var typeInstances = [];

      if (keyTypes.length === 0) {
        typeInstances.push(t.existential());
      } else if (keyTypes.length === 1) {
        typeInstances.push(keyTypes[0]);
      } else {
        typeInstances.push(t.union.apply(t, keyTypes));
      }

      if (valueTypes.length === 0) {
        typeInstances.push(t.existential());
      } else if (valueTypes.length === 1) {
        typeInstances.push(valueTypes[0]);
      } else {
        typeInstances.push(t.union.apply(t, valueTypes));
      }

      return typeInstances;
    }
  });

  t.declareTypeConstructor({
    name: 'Set',
    impl: Set,
    typeName: 'SetType',
    collectErrors(validation, path, input, valueType) {
      var context = this.context;

      if (!context.checkPredicate('Set', input)) {
        validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'));
        return true;
      }
      var hasErrors = false;
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = input[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var value = _step8.value;

          if (valueType.collectErrors(validation, path, value)) {
            hasErrors = true;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return hasErrors;
    },
    accepts(input, valueType) {
      var context = this.context;

      if (!context.checkPredicate('Set', input)) {
        return false;
      }
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = input[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var value = _step9.value;

          if (!valueType.accepts(value)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      return true;
    },
    inferTypeParameters(input) {
      var valueTypes = [];
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        loop: for (var _iterator10 = input[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var value = _step10.value;

          for (var i = 0; i < valueTypes.length; i++) {
            var type = valueTypes[i];
            if (type.accepts(value)) {
              continue loop; // foo.
            }
          }
          valueTypes.push(t.typeOf(value));
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      if (valueTypes.length === 0) {
        return [t.existential()];
      } else if (valueTypes.length === 1) {
        return [valueTypes[0]];
      } else {
        return [t.union.apply(t, valueTypes)];
      }
    }
  });

  // Ignores type errors.
  t.declareTypeConstructor({
    name: '$FlowIgnore',
    typeName: '$FlowIgnore',
    collectErrors(validation, path, input) {
      return false;
    },
    accepts(input) {
      return true;
    },
    inferTypeParameters(input) {
      return [];
    }
  });

  return t;
}