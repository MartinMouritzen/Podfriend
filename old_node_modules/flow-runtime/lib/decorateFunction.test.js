import decorateFunction from './decorateFunction';
import t from './globalContext';
import { throws } from 'assert';

describe('decorateFunction', function () {
  it('should decorate a function', function () {
    var adder = function adder(a, b) {
      return a + b;
    };
    var type = t.fn(t.param('a', t.number()), t.param('b', t.number()), t.return(t.number()));

    var decorated = decorateFunction(type, adder);

    console.log(decorated(1, 2));
  });

  it('should decorate a polymorphic function', function () {
    function adder(a, b) {
      return a + b;
    }
    var type = t.fn(function (Adder) {
      var T = Adder.typeParameter('T', t.union(t.number(), t.string()));
      return [t.param('a', T), t.param('b', T), t.return(T)];
    });

    var decorated = decorateFunction(type, adder);

    console.log(decorated(1, 2));
    console.log(decorated('hello ', 'world'));
    throws(function () {
      return decorated('hello ', 123);
    });
  });

  it('should decorate a fully polymorphic function', function () {
    function adder(a, b) {
      return a + b;
    }
    var type = t.fn(function (Adder) {
      var A = Adder.typeParameter('A', t.union(t.number(), t.string()));
      var B = Adder.typeParameter('B', t.union(t.number(), t.string()));
      return [t.param('a', A), t.param('b', B), t.return(t.union(A, B))];
    });

    var decorated = decorateFunction(type, adder);

    console.log(decorated(1, 2));
    console.log(decorated('hello ', 'world'));
    console.log(decorated('hello ', 123));
    throws(function () {
      // Ignore
      return decorated('hello ', { nope: true });
    });
  });

  it('should check a return value', function () {
    var stringer = function stringer(input) {
      return input;
    };
    var type = t.fn(t.param('input', t.any()), t.return(t.string()));

    decorateFunction(type, stringer);

    //console.log(decorated(false));
  });

  it('should decorate a generator', function () {
    function* oneTwoThree() {
      yield 1;
      yield 2;
      yield 3;
    }
    var type = t.fn(t.return(t.ref('Iterable', t.number())));
    var decorated = decorateFunction(type, oneTwoThree);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = decorated()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;

        console.log('got', value);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });
});