{"version":3,"sources":["../../src/differentialDownloader/DataSplitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { newError } from \"builder-util-runtime\"\nimport { createReadStream } from \"fs\"\nimport { Writable } from \"stream\"\nimport { Operation, OperationKind } from \"./downloadPlanBuilder\"\n\nconst DOUBLE_CRLF = Buffer.from(\"\\r\\n\\r\\n\")\n\nenum ReadState {\n  INIT, HEADER, BODY\n}\n\nexport interface PartListDataTask {\n  readonly oldFileFd: number\n  readonly tasks: Array<Operation>\n  readonly start: number\n  readonly end: number\n}\n\nexport function copyData(task: Operation, out: Writable, oldFileFd: number, reject: (error: Error) => void, resolve: () => void): void {\n  const readStream = createReadStream(\"\", {\n    fd: oldFileFd,\n    autoClose: false,\n    start: task.start,\n    // end is inclusive\n    end: task.end - 1,\n  })\n  readStream.on(\"error\", reject)\n  readStream.once(\"end\", resolve)\n  readStream.pipe(out, {\n    end: false\n  })\n}\n\nexport class DataSplitter extends Writable {\n  partIndex = -1\n\n  private headerListBuffer: Buffer | null = null\n  private readState = ReadState.INIT\n  private ignoreByteCount = 0\n  private remainingPartDataCount = 0\n\n  private readonly boundaryLength: number\n\n  constructor(private readonly out: Writable, private readonly options: PartListDataTask, private readonly partIndexToTaskIndex: Map<number, number>, boundary: string, private readonly partIndexToLength: Array<number>, private readonly finishHandler: () => any) {\n    super()\n\n    this.boundaryLength = boundary.length + 4 /* size of \\r\\n-- */\n    // first chunk doesn't start with \\r\\n\n    this.ignoreByteCount = this.boundaryLength - 2\n  }\n\n  get isFinished(): boolean {\n    return this.partIndex === this.partIndexToLength.length\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  _write(data: Buffer, encoding: string, callback: (error?: Error) => void): void {\n    if (this.isFinished) {\n      console.error(`Trailing ignored data: ${data.length} bytes`)\n      return\n    }\n\n    this.handleData(data)\n      .then(callback)\n      .catch(callback)\n  }\n\n  private async handleData(chunk: Buffer): Promise<undefined> {\n    let start = 0\n\n    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {\n      throw newError(\"Internal error\", \"ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH\")\n    }\n\n    if (this.ignoreByteCount > 0) {\n      const toIgnore = Math.min(this.ignoreByteCount, chunk.length)\n      this.ignoreByteCount -= toIgnore\n      start = toIgnore\n    }\n    else if (this.remainingPartDataCount > 0) {\n      const toRead = Math.min(this.remainingPartDataCount, chunk.length)\n      this.remainingPartDataCount -= toRead\n      await this.processPartData(chunk, 0, toRead)\n      start = toRead\n    }\n\n    if (start === chunk.length) {\n      return\n    }\n\n    if (this.readState === ReadState.HEADER) {\n      const headerListEnd = this.searchHeaderListEnd(chunk, start)\n      if (headerListEnd === -1) {\n        return\n      }\n\n      start = headerListEnd\n      this.readState = ReadState.BODY\n      // header list is ignored, we don't need it\n      this.headerListBuffer = null\n    }\n\n    while (true) {\n      if (this.readState === ReadState.BODY) {\n        this.readState = ReadState.INIT\n      }\n      else {\n        this.partIndex++\n\n        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex)\n        if (taskIndex == null) {\n          if (this.isFinished) {\n            taskIndex = this.options.end\n          }\n          else {\n            throw newError(\"taskIndex is null\", \"ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL\")\n          }\n        }\n\n        const prevTaskIndex = this.partIndex === 0 ? this.options.start : (this.partIndexToTaskIndex.get(this.partIndex - 1)!! + 1 /* prev part is download, next maybe copy */)\n        if (prevTaskIndex < taskIndex) {\n          await this.copyExistingData(prevTaskIndex, taskIndex)\n        }\n        else if (prevTaskIndex > taskIndex) {\n          throw newError(\"prevTaskIndex must be < taskIndex\", \"ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED\")\n        }\n\n        if (this.isFinished) {\n          this.onPartEnd()\n          this.finishHandler()\n          return\n        }\n\n        start = this.searchHeaderListEnd(chunk, start)\n\n        if (start === -1) {\n          this.readState = ReadState.HEADER\n          return\n        }\n      }\n\n      const partLength = this.partIndexToLength[this.partIndex]\n      const end = start + partLength\n      const effectiveEnd = Math.min(end, chunk.length)\n      await this.processPartStarted(chunk, start, effectiveEnd)\n      this.remainingPartDataCount = partLength - (effectiveEnd - start)\n      if (this.remainingPartDataCount > 0) {\n        return\n      }\n\n      start = end + this.boundaryLength\n      if (start >= chunk.length) {\n        this.ignoreByteCount = this.boundaryLength - (chunk.length - end)\n        return\n      }\n    }\n  }\n\n  private copyExistingData(index: number, end: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const w = (): void => {\n        if (index === end) {\n          resolve()\n          return\n        }\n\n        const task = this.options.tasks[index]\n        if (task.kind !== OperationKind.COPY) {\n          reject(new Error(\"Task kind must be COPY\"))\n          return\n        }\n\n        copyData(task, this.out, this.options.oldFileFd, reject, () => {\n          index++\n          w()\n        })\n      }\n      w()\n    })\n  }\n\n  private searchHeaderListEnd(chunk: Buffer, readOffset: number): number {\n    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset)\n    if (headerListEnd !== -1) {\n      return headerListEnd + DOUBLE_CRLF.length\n    }\n\n    // not all headers data were received, save to buffer\n    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset)\n    if (this.headerListBuffer == null) {\n      this.headerListBuffer = partialChunk\n    }\n    else {\n      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk])\n    }\n    return -1\n  }\n\n  private actualPartLength = 0\n\n  private onPartEnd(): void {\n    const expectedLength = this.partIndexToLength[this.partIndex - 1]\n    if (this.actualPartLength !== expectedLength) {\n      throw newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, \"ERR_DATA_SPLITTER_LENGTH_MISMATCH\")\n    }\n    this.actualPartLength = 0\n  }\n\n  private processPartStarted(data: Buffer, start: number, end: number): Promise<void> {\n    if (this.partIndex !== 0) {\n      this.onPartEnd()\n    }\n    return this.processPartData(data, start, end)\n  }\n\n  private processPartData(data: Buffer, start: number, end: number): Promise<void> {\n    this.actualPartLength += end - start\n    const out = this.out\n    if (out.write(start === 0 && data.length === end ? data : data.slice(start, end))) {\n      return Promise.resolve()\n    }\n    else {\n      return new Promise((resolve, reject) => {\n        out.on(\"error\", reject)\n        out.once(\"drain\", () => {\n          out.removeListener(\"error\", reject)\n          resolve()\n        })\n      })\n    }\n  }\n}"],"sourceRoot":""}
