{"version":3,"sources":["../src/electronHttpExecutor.ts"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAMO,MAAM,gBAAgB,GAAG,kBAAzB;;;AAED,SAAU,aAAV,GAAuB;AAC3B,SAAO,oBAAQ,aAAR,CAAsB,gBAAtB,EAAwC;AAC7C,IAAA,KAAK,EAAE;AADsC,GAAxC,CAAP;AAGD;;AAEK,MAAO,oBAAP,SAAoC,kCAApC,CAAwE;AAG5E,EAAA,WAAA,CAA6B,kBAA7B,EAAkG;AAChG;AAD2B,SAAA,kBAAA,GAAA,kBAAA;AAFrB,SAAA,aAAA,GAAgC,IAAhC;AAIP;;AAED,QAAM,QAAN,CAAe,GAAf,EAAyB,WAAzB,EAA8C,OAA9C,EAAsE;AACpE,WAAO,MAAM,OAAO,CAAC,iBAAR,CAA0B,aAA1B,CAAgD,CAAC,OAAD,EAAU,MAAV,EAAkB,QAAlB,KAA8B;AACzF,YAAM,cAAc,GAAG;AACrB,QAAA,OAAO,EAAE,OAAO,CAAC,OAAR,IAAmB,SADP;AAErB,QAAA,QAAQ,EAAE;AAFW,OAAvB;AAIA,qDAAoB,GAApB,EAAyB,cAAzB;AACA,yDAAwB,cAAxB;AACA,WAAK,UAAL,CAAgB,cAAhB,EAAgC;AAC9B,QAAA,WAD8B;AAE9B,QAAA,OAF8B;AAG9B,QAAA,QAH8B;AAI9B,QAAA,QAAQ,EAAE,KAAK,IAAG;AAChB,cAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAA,OAAO,CAAC,WAAD,CAAP;AACD,WAFD,MAGK;AACH,YAAA,MAAM,CAAC,KAAD,CAAN;AACD;AACF,SAX6B;AAY9B,QAAA,eAAe,EAAE;AAZa,OAAhC,EAaG,CAbH;AAcD,KArBY,CAAb;AAsBD;;AAED,EAAA,aAAa,CAAC,OAAD,EAAe,QAAf,EAAgD;AAE3D;AACA,QAAI,OAAO,CAAC,OAAR,IAAmB,OAAO,CAAC,OAAR,CAAgB,IAAvC,EAA4C;AAC1C;AACA,MAAA,OAAO,CAAC,IAAR,GAAe,OAAO,CAAC,OAAR,CAAgB,IAA/B,CAF0C,CAG1C;;AACA,aAAO,OAAO,CAAC,OAAR,CAAgB,IAAvB;AACD,KAR0D,CAU3D;;;AACA,QAAI,KAAK,aAAL,IAAsB,IAA1B,EAAgC;AAC9B,WAAK,aAAL,GAAqB,aAAa,EAAlC;AACD;;AAED,UAAM,OAAO,GAAG,gBAAI,OAAJ,CAAY,EAC1B,GAAG,OADuB;AAE1B,MAAA,OAAO,EAAE,KAAK;AAFY,KAAZ,CAAhB;;AAIA,IAAA,OAAO,CAAC,EAAR,CAAW,UAAX,EAAuB,QAAvB;;AACA,QAAI,KAAK,kBAAL,IAA2B,IAA/B,EAAqC;AACnC,MAAA,OAAO,CAAC,EAAR,CAAW,OAAX,EAAoB,KAAK,kBAAzB;AACD;;AACD,WAAO,OAAP;AACD;;AAES,EAAA,mBAAmB,CAAC,OAAD,EAAyB,OAAzB,EAAkD,MAAlD,EAAkF,aAAlF,EAAyG,OAAzG,EAAmJ;AAC9K,IAAA,OAAO,CAAC,EAAR,CAAW,UAAX,EAAuB,CAAC,UAAD,EAAqB,MAArB,EAAqC,WAArC,KAA4D;AACjF;AACA;AACA,MAAA,OAAO,CAAC,KAAR;;AAEA,UAAI,aAAa,GAAG,KAAK,YAAzB,EAAuC;AACrC,QAAA,MAAM,CAAC,KAAK,sBAAL,EAAD,CAAN;AACD,OAFD,MAGK;AACH,QAAA,OAAO,CAAC,mCAAa,yBAAb,CAAuC,WAAvC,EAAoD,OAApD,CAAD,CAAP;AACD;AACF,KAXD;AAYD;;AAvE2E,C","sourcesContent":["import { DownloadOptions, HttpExecutor, configureRequestOptions, configureRequestUrl } from \"builder-util-runtime\"\nimport { net, session } from \"electron\"\nimport { RequestOptions } from \"http\"\nimport Session = Electron.Session\nimport ClientRequest = Electron.ClientRequest\n\nexport type LoginCallback = (username: string, password: string) => void\nexport const NET_SESSION_NAME = \"electron-updater\"\n\nexport function getNetSession(): Session {\n  return session.fromPartition(NET_SESSION_NAME, {\n    cache: false\n  })\n}\n\nexport class ElectronHttpExecutor extends HttpExecutor<Electron.ClientRequest> {\n  private cachedSession: Session | null = null\n\n  constructor(private readonly proxyLoginCallback?: (authInfo: any, callback: LoginCallback) => void) {\n    super()\n  }\n\n  async download(url: URL, destination: string, options: DownloadOptions): Promise<string> {\n    return await options.cancellationToken.createPromise<string>((resolve, reject, onCancel) => {\n      const requestOptions = {\n        headers: options.headers || undefined,\n        redirect: \"manual\",\n      }\n      configureRequestUrl(url, requestOptions)\n      configureRequestOptions(requestOptions)\n      this.doDownload(requestOptions, {\n        destination,\n        options,\n        onCancel,\n        callback: error => {\n          if (error == null) {\n            resolve(destination)\n          }\n          else {\n            reject(error)\n          }\n        },\n        responseHandler: null,\n      }, 0)\n    })\n  }\n\n  createRequest(options: any, callback: (response: any) => void): any {\n\n    // fix (node 7+) for making electron updater work when using AWS private buckets, check if headers contain Host property\n    if (options.headers && options.headers.Host){\n      // set host value from headers.Host\n      options.host = options.headers.Host\n      // remove header property 'Host', if not removed causes net::ERR_INVALID_ARGUMENT exception\n      delete options.headers.Host;\n    }\n\n    // differential downloader can call this method very often, so, better to cache session\n    if (this.cachedSession == null) {\n      this.cachedSession = getNetSession()\n    }\n\n    const request = net.request({\n      ...options,\n      session: this.cachedSession,\n    })\n    request.on(\"response\", callback)\n    if (this.proxyLoginCallback != null) {\n      request.on(\"login\", this.proxyLoginCallback)\n    }\n    return request\n  }\n\n  protected addRedirectHandlers(request: ClientRequest, options: RequestOptions, reject: (error: Error) => void, redirectCount: number, handler: (options: RequestOptions) => void): void {\n    request.on(\"redirect\", (statusCode: number, method: string, redirectUrl: string) => {\n      // no way to modify request options, abort old and make a new one\n      // https://github.com/electron/electron/issues/11505\n      request.abort()\n\n      if (redirectCount > this.maxRedirects) {\n        reject(this.createMaxRedirectError())\n      }\n      else {\n        handler(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options))\n      }\n    })\n  }\n}"],"sourceRoot":""}
